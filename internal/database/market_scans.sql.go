// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: market_scans.sql

package database

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const deactivateMarketScan = `-- name: DeactivateMarketScan :exec
UPDATE market_scans
SET is_active = false, updated_at = NOW()
WHERE token_id = $1
`

func (q *Queries) DeactivateMarketScan(ctx context.Context, tokenID string) error {
	_, err := q.db.ExecContext(ctx, deactivateMarketScan, tokenID)
	return err
}

const getActiveMarketScans = `-- name: GetActiveMarketScans :many
SELECT id, token_id, event_id, slug, question, last_price, last_volume, liquidity, last_scanned_at, price_24h_ago, volume_24h_ago, scan_count, is_active, metadata, created_at, updated_at FROM market_scans
WHERE is_active = true
ORDER BY last_scanned_at ASC
LIMIT $1
`

func (q *Queries) GetActiveMarketScans(ctx context.Context, limit int32) ([]MarketScan, error) {
	rows, err := q.db.QueryContext(ctx, getActiveMarketScans, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MarketScan{}
	for rows.Next() {
		var i MarketScan
		if err := rows.Scan(
			&i.ID,
			&i.TokenID,
			&i.EventID,
			&i.Slug,
			&i.Question,
			&i.LastPrice,
			&i.LastVolume,
			&i.Liquidity,
			&i.LastScannedAt,
			&i.Price24hAgo,
			&i.Volume24hAgo,
			&i.ScanCount,
			&i.IsActive,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMarketEventsSince = `-- name: GetMarketEventsSince :many
SELECT id, token_id, event_type, old_value, new_value, metadata, detected_at FROM market_events
WHERE id > $1
ORDER BY id ASC
LIMIT 100
`

func (q *Queries) GetMarketEventsSince(ctx context.Context, id int32) ([]MarketEvent, error) {
	rows, err := q.db.QueryContext(ctx, getMarketEventsSince, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MarketEvent{}
	for rows.Next() {
		var i MarketEvent
		if err := rows.Scan(
			&i.ID,
			&i.TokenID,
			&i.EventType,
			&i.OldValue,
			&i.NewValue,
			&i.Metadata,
			&i.DetectedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMarketScan = `-- name: GetMarketScan :one
SELECT id, token_id, event_id, slug, question, last_price, last_volume, liquidity, last_scanned_at, price_24h_ago, volume_24h_ago, scan_count, is_active, metadata, created_at, updated_at FROM market_scans
WHERE token_id = $1
`

func (q *Queries) GetMarketScan(ctx context.Context, tokenID string) (MarketScan, error) {
	row := q.db.QueryRowContext(ctx, getMarketScan, tokenID)
	var i MarketScan
	err := row.Scan(
		&i.ID,
		&i.TokenID,
		&i.EventID,
		&i.Slug,
		&i.Question,
		&i.LastPrice,
		&i.LastVolume,
		&i.Liquidity,
		&i.LastScannedAt,
		&i.Price24hAgo,
		&i.Volume24hAgo,
		&i.ScanCount,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecentMarketEvents = `-- name: GetRecentMarketEvents :many
SELECT id, token_id, event_type, old_value, new_value, metadata, detected_at FROM market_events
WHERE detected_at > NOW() - INTERVAL '1 hour'
ORDER BY detected_at DESC
LIMIT $1
`

func (q *Queries) GetRecentMarketEvents(ctx context.Context, limit int32) ([]MarketEvent, error) {
	rows, err := q.db.QueryContext(ctx, getRecentMarketEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MarketEvent{}
	for rows.Next() {
		var i MarketEvent
		if err := rows.Scan(
			&i.ID,
			&i.TokenID,
			&i.EventType,
			&i.OldValue,
			&i.NewValue,
			&i.Metadata,
			&i.DetectedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordMarketEvent = `-- name: RecordMarketEvent :one
INSERT INTO market_events (
    token_id, event_type, old_value, new_value, metadata
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, token_id, event_type, old_value, new_value, metadata, detected_at
`

type RecordMarketEventParams struct {
	TokenID   string                `json:"token_id"`
	EventType sql.NullString        `json:"event_type"`
	OldValue  sql.NullFloat64       `json:"old_value"`
	NewValue  sql.NullFloat64       `json:"new_value"`
	Metadata  pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) RecordMarketEvent(ctx context.Context, arg RecordMarketEventParams) (MarketEvent, error) {
	row := q.db.QueryRowContext(ctx, recordMarketEvent,
		arg.TokenID,
		arg.EventType,
		arg.OldValue,
		arg.NewValue,
		arg.Metadata,
	)
	var i MarketEvent
	err := row.Scan(
		&i.ID,
		&i.TokenID,
		&i.EventType,
		&i.OldValue,
		&i.NewValue,
		&i.Metadata,
		&i.DetectedAt,
	)
	return i, err
}

const upsertMarketScan = `-- name: UpsertMarketScan :one
INSERT INTO market_scans (
    token_id, event_id, slug, question, 
    last_price, last_volume, liquidity,
    price_24h_ago, volume_24h_ago, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT (token_id) DO UPDATE SET
    event_id = EXCLUDED.event_id,
    slug = EXCLUDED.slug,
    question = EXCLUDED.question,
    last_price = EXCLUDED.last_price,
    last_volume = EXCLUDED.last_volume,
    liquidity = EXCLUDED.liquidity,
    last_scanned_at = NOW(),
    scan_count = market_scans.scan_count + 1,
    updated_at = NOW(),
    metadata = EXCLUDED.metadata,
    price_24h_ago = CASE 
        WHEN market_scans.last_scanned_at < NOW() - INTERVAL '24 hours' 
        THEN market_scans.last_price 
        ELSE COALESCE(market_scans.price_24h_ago, market_scans.last_price)
    END,
    volume_24h_ago = CASE 
        WHEN market_scans.last_scanned_at < NOW() - INTERVAL '24 hours' 
        THEN market_scans.last_volume 
        ELSE COALESCE(market_scans.volume_24h_ago, market_scans.last_volume)
    END
RETURNING id, token_id, event_id, slug, question, last_price, last_volume, liquidity, last_scanned_at, price_24h_ago, volume_24h_ago, scan_count, is_active, metadata, created_at, updated_at
`

type UpsertMarketScanParams struct {
	TokenID      string                `json:"token_id"`
	EventID      sql.NullString        `json:"event_id"`
	Slug         sql.NullString        `json:"slug"`
	Question     sql.NullString        `json:"question"`
	LastPrice    sql.NullFloat64       `json:"last_price"`
	LastVolume   sql.NullFloat64       `json:"last_volume"`
	Liquidity    sql.NullFloat64       `json:"liquidity"`
	Price24hAgo  sql.NullFloat64       `json:"price_24h_ago"`
	Volume24hAgo sql.NullFloat64       `json:"volume_24h_ago"`
	Metadata     pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) UpsertMarketScan(ctx context.Context, arg UpsertMarketScanParams) (MarketScan, error) {
	row := q.db.QueryRowContext(ctx, upsertMarketScan,
		arg.TokenID,
		arg.EventID,
		arg.Slug,
		arg.Question,
		arg.LastPrice,
		arg.LastVolume,
		arg.Liquidity,
		arg.Price24hAgo,
		arg.Volume24hAgo,
		arg.Metadata,
	)
	var i MarketScan
	err := row.Scan(
		&i.ID,
		&i.TokenID,
		&i.EventID,
		&i.Slug,
		&i.Question,
		&i.LastPrice,
		&i.LastVolume,
		&i.Liquidity,
		&i.LastScannedAt,
		&i.Price24hAgo,
		&i.Volume24hAgo,
		&i.ScanCount,
		&i.IsActive,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
