// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: microstructure.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const getActiveTokenIDs = `-- name: GetActiveTokenIDs :many
SELECT token_id
FROM market_scans
WHERE is_active = true
ORDER BY last_scanned_at DESC
LIMIT $1
`

// === Utility ===
func (q *Queries) GetActiveTokenIDs(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTokenIDs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var token_id string
		if err := rows.Scan(&token_id); err != nil {
			return nil, err
		}
		items = append(items, token_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMid = `-- name: GetLatestMid :one
SELECT mid
FROM market_quotes
WHERE token_id = $1
ORDER BY ts DESC
LIMIT 1
`

func (q *Queries) GetLatestMid(ctx context.Context, tokenID string) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, getLatestMid, tokenID)
	var mid sql.NullFloat64
	err := row.Scan(&mid)
	return mid, err
}

const insertQuote = `-- name: InsertQuote :exec
INSERT INTO market_quotes (
  token_id, ts, best_bid, best_ask, bid_size1, ask_size1, spread_bps, mid
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
`

type InsertQuoteParams struct {
	TokenID   string          `json:"token_id"`
	Ts        time.Time       `json:"ts"`
	BestBid   sql.NullFloat64 `json:"best_bid"`
	BestAsk   sql.NullFloat64 `json:"best_ask"`
	BidSize1  sql.NullFloat64 `json:"bid_size1"`
	AskSize1  sql.NullFloat64 `json:"ask_size1"`
	SpreadBps sql.NullFloat64 `json:"spread_bps"`
	Mid       sql.NullFloat64 `json:"mid"`
}

// === Quotes ===
func (q *Queries) InsertQuote(ctx context.Context, arg InsertQuoteParams) error {
	_, err := q.db.ExecContext(ctx, insertQuote,
		arg.TokenID,
		arg.Ts,
		arg.BestBid,
		arg.BestAsk,
		arg.BidSize1,
		arg.AskSize1,
		arg.SpreadBps,
		arg.Mid,
	)
	return err
}

const insertTrade = `-- name: InsertTrade :exec
INSERT INTO market_trades (
  token_id, ts, price, size, aggressor, trade_id
) VALUES (
  $1, $2, $3, $4, $5, $6
)
ON CONFLICT (trade_id) WHERE trade_id IS NOT NULL DO NOTHING
`

type InsertTradeParams struct {
	TokenID   string         `json:"token_id"`
	Ts        time.Time      `json:"ts"`
	Price     float64        `json:"price"`
	Size      float64        `json:"size"`
	Aggressor sql.NullString `json:"aggressor"`
	TradeID   sql.NullString `json:"trade_id"`
}

// === Trades ===
func (q *Queries) InsertTrade(ctx context.Context, arg InsertTradeParams) error {
	_, err := q.db.ExecContext(ctx, insertTrade,
		arg.TokenID,
		arg.Ts,
		arg.Price,
		arg.Size,
		arg.Aggressor,
		arg.TradeID,
	)
	return err
}

const upsertFeatures = `-- name: UpsertFeatures :exec
INSERT INTO market_features (
  token_id, ts, ret_1m, ret_5m, vol_1m, avg_vol_5m,
  sigma_5m, zscore_5m, imbalance_top, spread_bps,
  broke_high_15m, broke_low_15m, time_to_resolve_h, signed_flow_1m
) VALUES (
  $1, $2, $3, $4, $5, $6,
  $7, $8, $9, $10,
  $11, $12, $13, $14
)
ON CONFLICT (token_id, ts) DO UPDATE SET
  ret_1m = EXCLUDED.ret_1m,
  ret_5m = EXCLUDED.ret_5m,
  vol_1m = EXCLUDED.vol_1m,
  avg_vol_5m = EXCLUDED.avg_vol_5m,
  sigma_5m = EXCLUDED.sigma_5m,
  zscore_5m = EXCLUDED.zscore_5m,
  imbalance_top = EXCLUDED.imbalance_top,
  spread_bps = EXCLUDED.spread_bps,
  broke_high_15m = EXCLUDED.broke_high_15m,
  broke_low_15m = EXCLUDED.broke_low_15m,
  time_to_resolve_h = EXCLUDED.time_to_resolve_h,
  signed_flow_1m = EXCLUDED.signed_flow_1m
`

type UpsertFeaturesParams struct {
	TokenID        string          `json:"token_id"`
	Ts             time.Time       `json:"ts"`
	Ret1m          sql.NullFloat64 `json:"ret_1m"`
	Ret5m          sql.NullFloat64 `json:"ret_5m"`
	Vol1m          sql.NullFloat64 `json:"vol_1m"`
	AvgVol5m       sql.NullFloat64 `json:"avg_vol_5m"`
	Sigma5m        sql.NullFloat64 `json:"sigma_5m"`
	Zscore5m       sql.NullFloat64 `json:"zscore_5m"`
	ImbalanceTop   sql.NullFloat64 `json:"imbalance_top"`
	SpreadBps      sql.NullFloat64 `json:"spread_bps"`
	BrokeHigh15m   sql.NullBool    `json:"broke_high_15m"`
	BrokeLow15m    sql.NullBool    `json:"broke_low_15m"`
	TimeToResolveH sql.NullFloat64 `json:"time_to_resolve_h"`
	SignedFlow1m   sql.NullFloat64 `json:"signed_flow_1m"`
}

// === Features ===
func (q *Queries) UpsertFeatures(ctx context.Context, arg UpsertFeaturesParams) error {
	_, err := q.db.ExecContext(ctx, upsertFeatures,
		arg.TokenID,
		arg.Ts,
		arg.Ret1m,
		arg.Ret5m,
		arg.Vol1m,
		arg.AvgVol5m,
		arg.Sigma5m,
		arg.Zscore5m,
		arg.ImbalanceTop,
		arg.SpreadBps,
		arg.BrokeHigh15m,
		arg.BrokeLow15m,
		arg.TimeToResolveH,
		arg.SignedFlow1m,
	)
	return err
}
