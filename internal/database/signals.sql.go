// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: signals.sql

package database

import (
	"context"
	"database/sql"
)

const getRecentSignals = `-- name: GetRecentSignals :many
SELECT id, session_id, token_id, signal_type, timestamp, best_bid, best_ask, bid_liquidity, ask_liquidity, action_reason, confidence FROM market_signals
WHERE session_id = $1
ORDER BY timestamp DESC
LIMIT $2
`

type GetRecentSignalsParams struct {
	SessionID sql.NullInt32 `json:"session_id"`
	Limit     int32         `json:"limit"`
}

func (q *Queries) GetRecentSignals(ctx context.Context, arg GetRecentSignalsParams) ([]MarketSignal, error) {
	rows, err := q.db.QueryContext(ctx, getRecentSignals, arg.SessionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MarketSignal{}
	for rows.Next() {
		var i MarketSignal
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.TokenID,
			&i.SignalType,
			&i.Timestamp,
			&i.BestBid,
			&i.BestAsk,
			&i.BidLiquidity,
			&i.AskLiquidity,
			&i.ActionReason,
			&i.Confidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSignalsByType = `-- name: GetSignalsByType :many
SELECT id, session_id, token_id, signal_type, timestamp, best_bid, best_ask, bid_liquidity, ask_liquidity, action_reason, confidence FROM market_signals
WHERE session_id = $1 AND signal_type = $2
ORDER BY timestamp DESC
`

type GetSignalsByTypeParams struct {
	SessionID  sql.NullInt32 `json:"session_id"`
	SignalType string        `json:"signal_type"`
}

func (q *Queries) GetSignalsByType(ctx context.Context, arg GetSignalsByTypeParams) ([]MarketSignal, error) {
	rows, err := q.db.QueryContext(ctx, getSignalsByType, arg.SessionID, arg.SignalType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MarketSignal{}
	for rows.Next() {
		var i MarketSignal
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.TokenID,
			&i.SignalType,
			&i.Timestamp,
			&i.BestBid,
			&i.BestAsk,
			&i.BidLiquidity,
			&i.AskLiquidity,
			&i.ActionReason,
			&i.Confidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordSignal = `-- name: RecordSignal :one
INSERT INTO market_signals 
(session_id, token_id, signal_type, best_bid, best_ask, 
 bid_liquidity, ask_liquidity, action_reason, confidence)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, session_id, token_id, signal_type, timestamp, best_bid, best_ask, bid_liquidity, ask_liquidity, action_reason, confidence
`

type RecordSignalParams struct {
	SessionID    sql.NullInt32  `json:"session_id"`
	TokenID      string         `json:"token_id"`
	SignalType   string         `json:"signal_type"`
	BestBid      sql.NullString `json:"best_bid"`
	BestAsk      sql.NullString `json:"best_ask"`
	BidLiquidity sql.NullString `json:"bid_liquidity"`
	AskLiquidity sql.NullString `json:"ask_liquidity"`
	ActionReason sql.NullString `json:"action_reason"`
	Confidence   sql.NullString `json:"confidence"`
}

func (q *Queries) RecordSignal(ctx context.Context, arg RecordSignalParams) (MarketSignal, error) {
	row := q.db.QueryRowContext(ctx, recordSignal,
		arg.SessionID,
		arg.TokenID,
		arg.SignalType,
		arg.BestBid,
		arg.BestAsk,
		arg.BidLiquidity,
		arg.AskLiquidity,
		arg.ActionReason,
		arg.Confidence,
	)
	var i MarketSignal
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.TokenID,
		&i.SignalType,
		&i.Timestamp,
		&i.BestBid,
		&i.BestAsk,
		&i.BidLiquidity,
		&i.AskLiquidity,
		&i.ActionReason,
		&i.Confidence,
	)
	return i, err
}
