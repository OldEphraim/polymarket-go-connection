// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: archive_jobs.sql

package database

import (
	"context"
	"database/sql"
)

const archiveDone = `-- name: ArchiveDone :exec
INSERT INTO archive_jobs(table_name, ts_start, ts_end, s3_key, row_count, bytes_written, status)
VALUES ($1, $2, $3, $4, $5, $6, 'done')
ON CONFLICT (table_name, ts_start, ts_end)
DO UPDATE SET status='done', row_count=$5, bytes_written=$6, s3_key=$4
`

type ArchiveDoneParams struct {
	TableName    string       `json:"table_name"`
	TsStart      sql.NullTime `json:"ts_start"`
	TsEnd        sql.NullTime `json:"ts_end"`
	S3Key        string       `json:"s3_key"`
	RowCount     int64        `json:"row_count"`
	BytesWritten int64        `json:"bytes_written"`
}

func (q *Queries) ArchiveDone(ctx context.Context, arg ArchiveDoneParams) error {
	_, err := q.db.ExecContext(ctx, archiveDone,
		arg.TableName,
		arg.TsStart,
		arg.TsEnd,
		arg.S3Key,
		arg.RowCount,
		arg.BytesWritten,
	)
	return err
}

const archiveFail = `-- name: ArchiveFail :exec
INSERT INTO archive_jobs(table_name, ts_start, ts_end, s3_key, row_count, bytes_written, status)
VALUES ($1, $2, $3, $4, 0, 0, 'failed')
ON CONFLICT (table_name, ts_start, ts_end)
DO UPDATE SET status='failed', s3_key=$4
`

type ArchiveFailParams struct {
	TableName string       `json:"table_name"`
	TsStart   sql.NullTime `json:"ts_start"`
	TsEnd     sql.NullTime `json:"ts_end"`
	S3Key     string       `json:"s3_key"`
}

func (q *Queries) ArchiveFail(ctx context.Context, arg ArchiveFailParams) error {
	_, err := q.db.ExecContext(ctx, archiveFail,
		arg.TableName,
		arg.TsStart,
		arg.TsEnd,
		arg.S3Key,
	)
	return err
}

const archiveRecordedDone = `-- name: ArchiveRecordedDone :one
SELECT EXISTS(
  SELECT 1 FROM archive_jobs
  WHERE table_name = $1 AND ts_start = $2 AND ts_end = $3 AND status = 'done'
) AS recorded
`

type ArchiveRecordedDoneParams struct {
	TableName string       `json:"table_name"`
	TsStart   sql.NullTime `json:"ts_start"`
	TsEnd     sql.NullTime `json:"ts_end"`
}

func (q *Queries) ArchiveRecordedDone(ctx context.Context, arg ArchiveRecordedDoneParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, archiveRecordedDone, arg.TableName, arg.TsStart, arg.TsEnd)
	var recorded bool
	err := row.Scan(&recorded)
	return recorded, err
}

const archiveStart = `-- name: ArchiveStart :exec
INSERT INTO archive_jobs(table_name, ts_start, ts_end, s3_key, row_count, bytes_written, status)
VALUES ($1, $2, $3, $4, 0, 0, 'running')
ON CONFLICT (table_name, ts_start, ts_end) DO NOTHING
`

type ArchiveStartParams struct {
	TableName string       `json:"table_name"`
	TsStart   sql.NullTime `json:"ts_start"`
	TsEnd     sql.NullTime `json:"ts_end"`
	S3Key     string       `json:"s3_key"`
}

func (q *Queries) ArchiveStart(ctx context.Context, arg ArchiveStartParams) error {
	_, err := q.db.ExecContext(ctx, archiveStart,
		arg.TableName,
		arg.TsStart,
		arg.TsEnd,
		arg.S3Key,
	)
	return err
}
